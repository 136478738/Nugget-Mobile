//
//  Restore.swift
//  Nugget
//
//  Created by lemin on 9/11/24.
//

import Foundation

struct FileToRestore {
    let contents: Data
    let path: String
    var owner: Int32 = 501
    var group: Int32 = 501
}

class RestoreManager {
    static let shared = RestoreManager()
    
    private func addExploitedConcreteFile(list: inout [BackupFile], path: String, contents: Data, owner: Int32 = 501, group: Int32 = 501) {
        let url = URL(filePath: path)
        var basePath: String = "/var/backup"
        if #available(iOS 17, *) {
            // required on iOS 17.0+ since /var/mobile is on a separate partition
            basePath = url.path(percentEncoded: false).hasPrefix("/var/mobile/") ? "/var/mobile/backup" : "/var/backup"
        }
        
        list.append(Directory(path: "", domain: "SysContainerDomain-../../../../../../../..\(basePath)\(url.deletingLastPathComponent().path(percentEncoded: false))", owner: owner, group: group))
        list.append(ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../..\(basePath)\(url.path(percentEncoded: false))", contents: contents, owner: owner, group: group))
    }
    
    func restoreFiles(_ files: [FileToRestore], reboot: Bool = false) {
        // get the device and create a directory for the backup files
        let deviceList = MobileDevice.deviceList()
        var udid: String
        guard deviceList.count == 1 else {
            print("Invalid device count: \(deviceList.count)")
            return
        }
        
        udid = deviceList.first!
        
        let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let folder = documentsDirectory.appendingPathComponent(udid, conformingTo: .data)
        
        do {
            try? FileManager.default.removeItem(at: folder)
            try FileManager.default.createDirectory(at: folder, withIntermediateDirectories: false)
            
            var backupFiles: [BackupFile] = []
            for file in files {
                // for non exploit domains, the path will not start with /
                if !file.path.starts(with: "/") {
                    // file is a regular domain, does not utilize exploit
                    let path_items = file.path.components(separatedBy: "/")
                    guard path_items.count > 0 else { continue }
                    let domain = path_items[0]
                    backupFiles.append(Directory(path: "", domain: domain))
                    var full_path = ""
                    for i in 1...(path_items.count - 1) {
                        if full_path != "" {
                            full_path += "/"
                        }
                        full_path += path_items[i]
                        if i < path_items.count - 1 {
                            // it is a directory
                            backupFiles.append(Directory(path: full_path, domain: domain))
                        } else {
                            // it is a file
                            backupFiles.append(ConcreteFile(path: full_path, domain: domain, contents: file.contents, owner: file.owner, group: file.group))
                        }
                    }
                } else {
                    // file utilizes exploit
                    addExploitedConcreteFile(list: &backupFiles, path: file.path, contents: file.contents, owner: file.owner, group: file.group)
                }
            }
            // crash on purpose to skip setup
            backupFiles.append(ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../../crash_on_purpose", contents: Data(), owner: 501, group: 501))
            
            // create backup
            let mbdb = Backup(files: backupFiles)
            try mbdb.writeTo(directory: folder)
            
            // Restore now
            var restoreArgs = [
                "idevicebackup2",
                "-n", "restore", "--no-reboot", "--system",
                documentsDirectory.path(percentEncoded: false)
            ]
            print("Executing args: \(restoreArgs)")
            var argv = restoreArgs.map{ strdup($0) }
            let result = idevicebackup2_main(Int32(restoreArgs.count), &argv)
            print("idevicebackup2 exited with code \(result)")
            if reboot, let result = result as? Int, result == 0 {
                print("Rebooting device...")
                MobileDevice.rebootDevice(udid: udid)
            }
        } catch {
            print(error.localizedDescription)
            return
        }
    }
}
